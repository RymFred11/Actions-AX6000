这是一个markdown文件，建议使用markdown软件打开，或直接访问github，打开最新链接：  
https://github.com/lgs2007m/Actions-OpenWrt/blob/main/刷机教程

mt798x的fip分区实际上包含bl31+uboot，为了方便理解，这里将fip直接称为uboot。  

本教程使用的是我基于hanwckf大佬bl-mt798x仓库修改编译的bl2、uboot和gpt，固件推荐使用immortalwrt-mt798x仓库编译的闭源单分区固件。  
大雕lean的QWRT也是闭源单分区固件，也可以使用。  



- ### 准备刷机文件和工具软件

SSH工具软件：Xshell https://pan.lanzoui.com/b0f19ry9g  或者putty https://www.423down.com/11333.html  
文件传输工具软件：WinSCP https://www.ghxi.com/winscp.html  
下载仓库中的刷机文件压缩包，里面包含了需要的刷机文件。  

- ### 0.开SSH
百里没有软破解SSH，是通过在原厂固件升级官方的原生OP获取SSH权限再刷第三方OP的。  
在原厂系统下，升级原生OP：  
openwrt-re-cp-03-4.1.0.r4005-1287bf0122329d5c3acbb7198e04b1e4.bin  
注意：升级原生OP官方宣传会失去保修。  

重启后，SSH登录192.168.68.1，端口22，用户名root，没有密码。  
输入命令删除这两个环境变量：  
```
fw_setenv jdc_crc_version
fw_setenv jdc_opp_version
```


- ### 1.备份原厂分区
只需要备份到mmcblk0p12 swap即可，最后一个mmcblk0p13 storage分区太大不备份了。  
因为plugin、swap分区都有1G，比较大，所以备份到/mnt/mmcblk0p13中，然后使用WinScp登录再下载下来。  
WinScp软件登录路由，协议SCP，IP 192.168.68.1，端口22。  
WinScp下载大文件提示主机超过15秒无通信，需要点击高级，高级站点设置-连接 去掉勾选“优化连接缓冲大小”，再点击登录。  

提示：bl2在/dev/mmcblk0boot0，uboot在fip分区。  
unpartitioned.bin是全0的空白文件，是为了后面可以使用备份的分区按顺序直接合并得到一个eMMC img镜像。  
除更换eMMC，这个img基本用不到，不过还是全部分区备份为好。  
**注意：放在一起的命令可以全部复制粘贴、一次执行，下同，不再赘述。**  

直接复制下面全部命令，粘贴执行即可，等待执行完成：  
```
dd if=/dev/mmcblk0boot0 of=/mnt/mmcblk0p13/mmcblk0boot0_bl2.bin conv=fsync
dd if=/dev/mmcblk0p1 of=/mnt/mmcblk0p13/mmcblk0p1_PMBR.bin conv=fsync
dd if=/dev/mmcblk0 bs=512 skip=34 count=8158 of=/mnt/mmcblk0p13/mmcblk0p1_unpartitioned.bin conv=fsync
dd if=/dev/mmcblk0p2 of=/mnt/mmcblk0p13/mmcblk0p2_u-boot-env.bin conv=fsync
dd if=/dev/mmcblk0p3 of=/mnt/mmcblk0p13/mmcblk0p3_factory.bin conv=fsync
dd if=/dev/mmcblk0p4 of=/mnt/mmcblk0p13/mmcblk0p4_fip.bin conv=fsync
dd if=/dev/mmcblk0p5 of=/mnt/mmcblk0p13/mmcblk0p5_kernel.bin conv=fsync
dd if=/dev/mmcblk0p6 of=/mnt/mmcblk0p13/mmcblk0p6_rootfs.bin conv=fsync
dd if=/dev/mmcblk0p7 of=/mnt/mmcblk0p13/mmcblk0p7_kernel2.bin conv=fsync
dd if=/dev/mmcblk0p8 of=/mnt/mmcblk0p13/mmcblk0p8_rootfs2.bin conv=fsync
dd if=/dev/mmcblk0p9 of=/mnt/mmcblk0p13/mmcblk0p9_rootfs_data.bin conv=fsync
dd if=/dev/mmcblk0p10 of=/mnt/mmcblk0p13/mmcblk0p10_log.bin conv=fsync
dd if=/dev/mmcblk0p11 of=/mnt/mmcblk0p13/mmcblk0p11_plugin.bin conv=fsync
dd if=/dev/mmcblk0p12 of=/mnt/mmcblk0p13/mmcblk0p12_swap.bin conv=fsync
```
执行完后使用WinSCP之类的软件登录路由器，到/mnt/mmcblk0p13下载下来保存到电脑。  

注：/mnt/mmcblk0p13里的aiecpluginD、jdc_docker文件夹里面是跑分的缓存数据。  
如果不大，也可自行压缩后备份，刷机后直接恢复到storage分区，这样回原厂跑分直接用这些数据，可以更快恢复跑分。  
太大就不建议备份，不要也无所谓，回原厂后重新缓存。  

- ### 2.刷bl2和单分区uboot
- 左边双击绿色文件夹，双击后进入tmp文件夹
- 这里将我“bl2和单分区uboot”文件夹中所有文件拖放到tmp文件夹中
- 
百里的bl2和uboot是开启了Secure Boot验证的，需要把bl2和uboot所在fip分区一起替换掉，不能只替换uboot！！！  
因为有些数据洁癖，我直接将编译得到的bl2二进制文件尾部填充0扩大至256KB，fip尾部填充0至2048KB。  
这样刷文件就可直接覆盖有数据部分，和清空分区再刷是一样，所以文件看着有点大。  
直接使用编译得到的原始文件也没问题，只是文件大小不一，原分区上可能有点多余数据不会被覆盖，这也不影响使用。  

将mt7986_jdcloud_re-cp-03-bl2_mod.bin和mt7986_jdcloud_re-cp-03-fip_mod.bin上传tmp文件夹，SSH输入命令验证md5：  
```
md5sum /tmp/mt7986_jdcloud_re-cp-03*_mod.bin
```
我这个2024.04.05版的bl2、uboot，md5值是这样：  
```
root@OpenWrt:~# md5sum /tmp/mt7986_jdcloud_re-cp-03-*_mod.bin
ba6edf33d825811ddabc11b54312cccd  /tmp/mt7986_jdcloud_re-cp-03-bl2_mod.bin
cc78be76b99ed27ed6e8a6f7cef112c2  /tmp/mt7986_jdcloud_re-cp-03-fip_mod.bin
```
核对md5正常后，输入命令刷写bl2和uboot，命令全部复制一起执行：  
```
ash
echo 0 > /sys/block/mmcblk0boot0/force_ro
dd if=/tmp/mt7986_jdcloud_re-cp-03-bl2_mod.bin of=/dev/mmcblk0boot0 conv=fsync
echo 1 > /sys/block/mmcblk0boot0/force_ro
dd if=/tmp/mt7986_jdcloud_re-cp-03-fip_mod.bin of=$(blkid -t PARTLABEL=fip -o device) conv=fsync
```
刷写完没有报错，则检查下分区的md5值，和我一样即可，不一样就重新刷，不能重启！！  
```
md5sum /dev/mmcblk0boot0 && md5sum $(blkid -t PARTLABEL=fip -o device)
```
输出结果和我一样即可：  
```
root@OpenWrt:~# md5sum /dev/mmcblk0boot0 && md5sum $(blkid -t PARTLABEL=fip -o device)
57b4fda67b6ef534f50fa5b7f1f15be4  /dev/mmcblk0boot0
cc78be76b99ed27ed6e8a6f7cef112c2  /dev/mmcblk0p4
```
到这里bl2和单分区uboot已经刷好了，不要重启，接着刷单分区gpt分区表。  

注：如果是从带有一个config分区的ImmortalWrt单分区分区表刷这个单分区，这里验证fip分区的md5是不一样的。  
因为ImmortalWrt的单分区的把原厂2M的fip扩大到了4M，我这个分区表还是保持fip为2M。  
下面再刷我的这个gpt分区表之后，fip分区会变为2M，分区的md5就会和我的一样了。  

天灵和大雕的刷机命令是直接使用偏移量，因为fip分区偏移量不变，所以不用管设备号。  
我上面刷uboot的命令自动找fip分区所在设备号，也不用你管设备号，可以直接用。  
更新uboot建议使用我教程的命令，或者直接进uboot webui里面更新即可。bl2一般不需要再更新了。  

- ### 3.刷单分区gpt分区表
原生OP没有sgdisk，刷单分区gpt分区表前，首先安装sgdisk以便后面编辑分区表。  
运行下面命令安装：  
```
opkg install -d root /tmp/sgdisk_1.0.6-1_aarch64_cortex-a53.ipk
```
分区表文件夹中的gpt文件，rootfs512M对应rootfs是512MB大小，依次类推。  
这个rootfs就是固件+overlay的大小，overlay近似是刷固件后剩余软件包空间大小，选择自己需要的rootfs大小的分区表即可。  
因为刷分区表是改变了后面的分区的偏移量，所以后面分区的数据就不能识别了。  
后面会讲到，如果要回原厂跑分，需要先恢复log、plugin、swap，后面新建的最后一个storage分区也要格式化才能用。  

上传你需要rootfs大小的gpt分区表文件到tmp文件夹，先验证md5：  
```
md5sum /tmp/jdcloud_re-cp-03_single-boot_rootfs*M_no-last-partition-gpt.bin
```
```
root@OpenWrt:~# md5sum /tmp/jdcloud_re-cp-03_single-boot_rootfs*M_no-last-partition-gpt.bin
234744da27ad54233bc3d528b05443a1  /tmp/jdcloud_re-cp-03_single-boot_rootfs512M_no-last-partition-gpt.bin
e120108dbfd143dc2b92d0ed8ad0e7f2  /tmp/jdcloud_re-cp-03_single-boot_rootfs1024M_no-last-partition-gpt.bin
514797957059d0a808a3ab53327d79c4  /tmp/jdcloud_re-cp-03_single-boot_rootfs2048M_no-last-partition-gpt.bin
```
你上传的文件的md5信息和上面对应文件的md5对比，没问题即可。  
接着修改下面命令中的gpt文件名为你上传的文件名，然后复制命令粘贴一起执行：  
（只修改gpt文件名，其他不变，这里以rootfs512M的分区表为例）  
dd命令是写入gpt文件到/dev/mmcblk0的前34个扇区  
sgdisk是用未分配空间新建storage分区  
```
dd if=/tmp/jdcloud_re-cp-03_single-boot_rootfs512M_no-last-partition-gpt.bin of=/dev/mmcblk0 bs=512 count=34 conv=fsync && \
sgdisk -e -n 0:0:0 -c 0:storage -t 0:0FC63DAF-8483-4772-8E79-3D69D8477DE4 -u 0:5D18C072-ADB3-412B-BF95-37617B01ADF8 -p /dev/mmcblk0
```
你会看到如下输出：  
```
root@OpenWrt:~# dd if=/tmp/jdcloud_re-cp-03_single-boot_rootfs512M_no-last-partition-gpt.bin of=/dev/mmcblk0 bs=512 count=34 conv=fsync && \
> sgdisk -e -n 0:0:0 -c 0:storage -t 0:0FC63DAF-8483-4772-8E79-3D69D8477DE4 -u 0:5D18C072-ADB3-412B-BF95-37617B01ADF8 -p /dev/mmcblk0
34+0 records in
34+0 records out
Setting name!
partNum is 8
Disk /dev/mmcblk0: 241664000 sectors, 115.2 GiB
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): 2BD17853-102B-4500-AA1A-8A21D4D7984D
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 241663966
Partitions will be aligned on 1024-sector boundaries
Total free space is 8158 sectors (4.0 MiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            8192            9215   512.0 KiB   8300  u-boot-env
   2            9216           13311   2.0 MiB     8300  factory
   3           13312           17407   2.0 MiB     8300  fip
   4           17408           50175   16.0 MiB    8300  kernel
   5           50176         1098751   512.0 MiB   8300  rootfs
   6         1098752         1232895   65.5 MiB    8300  log
   7         1232896         3330047   1024.0 MiB  8300  plugin
   8         3330048         5427199   1024.0 MiB  8300  swap
   9         5427200       241663966   112.6 GiB   8300  storage
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot or after you
run partprobe(8) or kpartx(8)
The operation has completed successfully.
```
dd写入没有报错，sgdisk最后输出successfully即可，有错误则及时排错，重新刷。  
检查第5分区rootfs是分区表设置的大小，比如rootfs512M的分区表rootfs就是512MB。  
检查第9分区storage大小接近整个EMMC大小，比如128G EMMC，storage分区有112GB左右。  


```
都没有问题可以断电，按reset上电进uboot刷固件了。  

